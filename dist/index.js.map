{"version":3,"sources":["../src/index.ts","../src/files/IOFiles.ts","../src/files/mimeType.ts","../src/terminal/terminalColors.ts","../src/utils/time.ts","../src/terminal/logger.ts","../src/terminal/terminalinteractive.ts"],"sourcesContent":["export * from \"./files/IOFiles\"\r\nexport * from \"./files/mimeType\"\r\n\r\nexport * from \"./terminal/logger\"\r\nexport * from \"./terminal/terminalColors\" \r\nexport * from \"./terminal/terminalinteractive\"\r\n\r\nexport * from \"./utils/time\"\r\n\r\nexport * from \"./types/index.type\"\r\n","import * as crypto from \"crypto\";\r\nimport * as path from \"path\";\r\nimport * as fs from \"fs\";\r\nimport chokidar, { FSWatcherKnownEventMap } from \"chokidar\";\r\nimport { mimeType } from \"./mimeType\";\r\nimport { FileType } from \"@/types/index.type\";\r\n\r\n/**\r\n * IOF (Input/Output File) class provides methods for file and directory operations,\r\n * including creating directories, removing files, watching directories for changes,\r\n * reading and writing JSON files, calculating file hashes and sizes, and saving files.\r\n */\r\nexport class IOF {\r\n\r\n    /**\r\n     * Checks if a file exists at the specified path.\r\n     * @param filePath - The path to the file.\r\n     * @returns A boolean indicating whether the file exists.\r\n     * @throws An error if the existence check fails.\r\n     */\r\n    public static existsFileSync(filePath: string): boolean {\r\n        try {\r\n            return fs.existsSync(filePath);\r\n        } catch (error) {\r\n            throw new Error(`Failed to check existence of ${filePath}: ${error instanceof Error ? error.message : String(error)}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Asynchronously checks if a file exists at the specified path.\r\n     * @param filePath - The path to the file.\r\n     * @returns A promise that resolves to a boolean indicating whether the file exists.\r\n     * @throws An error if the existence check fails.\r\n     */\r\n    public static async existsFile(filePath: string): Promise<boolean> {\r\n        try {\r\n            return await fs.promises.access(filePath, fs.constants.F_OK).then(() => true).catch(() => false);\r\n        } catch (error) {\r\n            throw new Error(`Failed to check existence of ${filePath}: ${error instanceof Error ? error.message : String(error)}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a directory if it does not exist.\r\n     * @param dirPath - The path of the directory to create.\r\n     */\r\n    public static mkdir(dirPath: string): void {\r\n        try {\r\n            if (!this.existsFileSync(dirPath)) {\r\n                fs.mkdirSync(dirPath, { recursive: true });\r\n            }\r\n        } catch (error) {\r\n            throw new Error(`Failed to create directory at ${dirPath}:  ${error instanceof Error ? error.message : String(error)}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes a directory or file at the specified path.\r\n     * If the path is a directory, it will be removed recursively.\r\n     * @param dirPath - The path of the directory to remove.\r\n     */\r\n    public static rm(dirPath: string): void {\r\n        try {\r\n            if (this.existsFileSync(dirPath)) {\r\n                fs.rmSync(dirPath, { recursive: true, force: true });\r\n            }\r\n        } catch (error) {\r\n            throw new Error(`Failed to remove at ${dirPath}: ${error instanceof Error ? error.message : String(error)}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Watches a directory for file system events and executes a callback with the event details.\r\n     * @param options - The options for the watcher.\r\n     * @param options.dirPath - The path of the directory to watch.\r\n     * @param options.event - The type of event to listen for (e.g., \"add\", \"change\", \"unlink\").\r\n     * @param options.onEvent - Optional callback function to handle file system events.\r\n     * \r\n     */\r\n    public static watcher(\r\n        options: {\r\n            /**\r\n             * The path of the directory to watch.\r\n             */\r\n            dirPath: string;\r\n            /**\r\n             * The type of event to listen for.\r\n             */\r\n            event: keyof FSWatcherKnownEventMap | \"add\" | \"change\" | \"addDir\" | \"unlink\" | \"unlinkDir\";\r\n            /**\r\n             * Optional callback function to handle file system events.\r\n             */\r\n            onEvent?: (\r\n                args: {\r\n                    /**\r\n                     * The full path of the file that triggered the event.\r\n                     */\r\n                    filePath: string;\r\n                    /**\r\n                     * The type of event that occurred.\r\n                     */\r\n                    event: keyof FSWatcherKnownEventMap | \"add\" | \"change\" | \"addDir\" | \"unlink\" | \"unlinkDir\";\r\n                }\r\n            ) => Promise<void>;\r\n        }\r\n    ) {\r\n        const { dirPath, event, onEvent } = options;\r\n        const fullPath = path.resolve(process.cwd(), dirPath);\r\n        const watcher = chokidar.watch(fullPath, { persistent: true });\r\n        watcher.on(event, async (filePath: string) => {\r\n            if (onEvent) {\r\n                await onEvent({\r\n                    filePath: path.resolve(process.cwd(), filePath),\r\n                    event,\r\n                });\r\n            }\r\n        });\r\n        watcher.on(\"error\", async (error) => {\r\n            throw new Error(`Watcher error: ${error instanceof Error ? error.message : String(error)}`);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Writes data to a JSON file. Can either append to existing array or overwrite the file.\r\n     * @param filePath - The path to the JSON file.\r\n     * @param data - The data to write to the file (single object or array).\r\n     * @param overwrite - If true, overwrites the file. If false, appends to existing array. Default is false.\r\n     * @throws An error if the file cannot be written or if the content is not an array.\r\n     */\r\n    public static async writeJSONFile<T>(params: { \r\n        filePath: string; \r\n        data: T | T[]; \r\n        overwrite?: boolean \r\n    }): Promise<void> {\r\n        const { filePath, data, overwrite = false } = params;\r\n        try {\r\n            if (!IOF.existsFileSync(path.dirname(filePath))) {\r\n                IOF.mkdir(path.dirname(filePath));\r\n            }\r\n\r\n            let finalData: T[];\r\n\r\n            if (overwrite || !this.existsFileSync(filePath)) {\r\n                finalData = Array.isArray(data) ? data : [data];\r\n            } else {\r\n                const jsonData = await fs.promises.readFile(filePath, \"utf-8\");\r\n                let arrayData = JSON.parse(jsonData);\r\n                if (!Array.isArray(arrayData)) arrayData = [];\r\n                \r\n                if (Array.isArray(data)) {\r\n                    finalData = [...arrayData, ...data];\r\n                } else {\r\n                    finalData = [...arrayData, data];\r\n                }\r\n            }\r\n\r\n            const newJsonData = JSON.stringify(finalData, null, 2);\r\n            await fs.promises.writeFile(filePath, newJsonData);\r\n        } catch (error) {\r\n            throw new Error(`Failed to write JSON to ${filePath}: ${error instanceof Error ? error.message : String(error)}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reads a JSON file and returns its content as an array.\r\n     * @param filePath - The path to the JSON file.\r\n     * @returns An array of objects parsed from the JSON file.\r\n     * @throws An error if the file does not exist or if the content is not an array.\r\n     */\r\n    public static async readJSONFile<T>(filePath: string): Promise<T[]> {\r\n        try {\r\n            if (!fs.existsSync(filePath)) {\r\n                throw new Error(`File not found: ${filePath}`);\r\n            }\r\n            const jsonData = await fs.promises.readFile(filePath, \"utf-8\");\r\n            const arr = JSON.parse(jsonData);\r\n            if (!Array.isArray(arr)) {\r\n                throw new Error(`File content is not an array: ${filePath}`);\r\n            }\r\n            return arr as T[];\r\n        } catch (error) {\r\n            throw new Error(`Failed to read JSON from ${filePath}: ${error instanceof Error ? error.message : String(error)}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates the SHA-256 hash of a given buffer.\r\n     * @param buffer - The buffer to hash.\r\n     * @returns The SHA-256 hash as a hexadecimal string.\r\n     */\r\n    public static calculateHashByBuffer(buffer: Buffer): string {\r\n        if (!Buffer.isBuffer(buffer)) {\r\n            throw new Error(\"Input must be a Buffer\");\r\n        }\r\n        if (buffer.length === 0) {\r\n            throw new Error(\"Buffer cannot be empty\");\r\n        }\r\n        return crypto.createHash(\"sha256\").update(buffer).digest(\"hex\");\r\n    }\r\n\r\n    /**\r\n     * Calculates the size of a file based on its buffer.\r\n     * @param buffer - The buffer representing the file.\r\n     * @returns The size of the file in bytes.\r\n     */\r\n    public static calculateSizeByBuffer(buffer: Buffer): number {\r\n        if (!Buffer.isBuffer(buffer)) {\r\n            throw new Error(\"Input must be a Buffer\");\r\n        }\r\n        if (buffer.length === 0) {\r\n            throw new Error(\"Buffer cannot be empty\");\r\n        }\r\n        return Buffer.byteLength(buffer);\r\n    }\r\n\r\n\r\n    /**\r\n     * Saves a file buffer to the specified file path on disk.\r\n     *\r\n     * Calculates the file's hash, size, and MIME type, creates the necessary directories,\r\n     * and writes the file data to disk. Returns an object containing metadata about the saved file.\r\n     *\r\n     * @param data - An object implementing the FileInterface, containing the file data, filename, and target filepath.\r\n     * @returns A promise that resolves to a FileMetadata object with file metadata, or null if saving fails.\r\n     * @throws {Error} If the file cannot be saved to the specified location.\r\n     */\r\n    public async saveBufferToFile(data: FileType.FileData): Promise<FileType.FileMetadata | null> {\r\n        const hash = IOF.calculateHashByBuffer(Buffer.from(data.filedata));\r\n        const size = IOF.calculateSizeByBuffer(Buffer.from(data.filedata));\r\n        const type = mimeType(data.filename);\r\n\r\n        try {\r\n            const fullPath = path.resolve(process.cwd(), data.filepath, data.filename);\r\n            const dir = path.dirname(fullPath);\r\n            IOF.mkdir(dir);\r\n            await fs.promises.writeFile(fullPath, data.filedata);\r\n\r\n            return {\r\n                filename: data.filename,\r\n                fileuri: fullPath,\r\n                filehash: hash,\r\n                filesize: size,\r\n                mimeType: type,\r\n                inlineData: Buffer.from(data.filedata).toString(\"base64\"),\r\n            };\r\n        } catch (error) {\r\n            throw new Error(`Failed to set file location: ${error instanceof Error ? error.message : String(error)}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Downloads a file from a given URL and saves it to the specified download path.\r\n     * @param data - The file download data including the file URL and save path.\r\n     * @returns The metadata of the downloaded file.\r\n     */\r\n    public static async downloadFile(data: FileType.FileDownloadRequest): Promise<FileType.FileMetadata> {\r\n        try {\r\n            const response = await fetch(data.fileuri);\r\n            const buffer = await response.arrayBuffer();\r\n            const fileName = path.basename(data.fileuri);\r\n            const filePath = path.join(data.saveTo, fileName);\r\n            fs.writeFileSync(filePath, Buffer.from(buffer));\r\n            return {\r\n                filename: fileName,\r\n                fileuri: filePath,\r\n                filehash: IOF.calculateHashByBuffer(Buffer.from(buffer)),\r\n                filesize: IOF.calculateSizeByBuffer(Buffer.from(buffer)),\r\n                mimeType: mimeType(fileName),\r\n                inlineData: Buffer.from(buffer).toString(\"base64\"),\r\n            };\r\n        } catch (error) {\r\n            throw new Error(`Failed to download file: ${error}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieves the string content of a text file.\r\n     * @param filePath - The path to the text file.\r\n     * @returns A promise that resolves to the content of the file as a string.\r\n     * @throws An error if the file cannot be read.\r\n     */\r\n    public static async readTextFile(filePath: string): Promise<string> {\r\n        try {\r\n            const data = await fs.promises.readFile(filePath, \"utf-8\");\r\n            return data;\r\n        } catch (error) {\r\n            throw new Error(`Failed to read file at ${filePath}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts a file to a generative path format suitable for AI/ML models.\r\n     * \r\n     * Reads a file from the filesystem and converts it to a base64-encoded format\r\n     * with MIME type information, wrapped in the structure expected by generative AI APIs.\r\n     * \r\n     * @param fileName - The path to the file to be converted\r\n     * @returns A promise that resolves to an object containing the file data in generative path format\r\n     * @returns The returned object has an `inlineData` property with `data` (base64 string) and `mimeType`\r\n     * \r\n     * @throws {Error} When file reading fails or MIME type detection fails\r\n     * \r\n     * @example\r\n     * ```typescript\r\n     * const generativePath = await fileToGenerativePath('./image.png');\r\n     * // Returns: { inlineData: { data: \"iVBORw0KGgoAAAANSUhEUgAA...\", mimeType: \"image/png\" } }\r\n     * ```\r\n     */\r\n    public async fileToGenerativePath(fileName: string) {\r\n        try {\r\n            const mime = mimeType(fileName);\r\n            const file = await fs.promises.readFile(fileName);\r\n            return {\r\n                inlineData: {\r\n                    data: Buffer.from(file).toString(\"base64\"),\r\n                    mimeType: mime,\r\n                },\r\n            };\r\n        } catch (error) {\r\n            throw new Error(`Failed to convert file to generative path: ${error}`);\r\n        }\r\n    }\r\n}\r\n","export function mimeType(fileName: string) {\r\n    const ext = fileName.split(\".\").pop();\r\n    switch (ext) {\r\n      // video\r\n      case \"mp4\":\r\n        return \"video/mp4\";\r\n      case \"mpeg\":\r\n      case \"mpg\":\r\n      case \"mpe\":\r\n      case \"mpv\":\r\n      case \"mp2\":\r\n      case \"m2v\":\r\n      case \"m2ts\":\r\n      case \"mts\":\r\n      case \"tts\":\r\n      case \"m2t\":\r\n      case \"tsv\":\r\n      case \"tsa\":\r\n        return \"video/mpeg\";\r\n      case \"webm\":\r\n        return \"video/webm\";\r\n      case \"3gp\":\r\n        return \"video/3gpp\";\r\n      case \"mkv\":\r\n        return \"video/x-matroska\";\r\n      case \"avi\":\r\n        return \"video/x-msvideo\";\r\n      case \"mov\":\r\n        return \"video/quicktime\";\r\n      case \"wmv\":\r\n        return \"video/x-ms-wmv\";\r\n      case \"flv\":\r\n        return \"video/x-flv\";\r\n      case \"m4v\":\r\n        return \"video/x-m4v\";\r\n  \r\n      //  audio\r\n      case \"mp3\":\r\n        return \"audio/mpeg\";\r\n      case \"m4a\":\r\n        return \"audio/mp4\";\r\n      case \"m4b\":\r\n      case \"m4p\":\r\n      case \"m4r\":\r\n        return \"audio/mp4\";\r\n      case \"wav\":\r\n        return \"audio/wav\";\r\n      case \"ogg\":\r\n        return \"audio/ogg\";\r\n      case \"aac\":\r\n        return \"audio/aac\";\r\n      case \"flac\":\r\n        return \"audio/flac\";\r\n      case \"alac\":\r\n        return \"audio/alac\";\r\n  \r\n      // image\r\n      case \"jpg\":\r\n      case \"jpeg\":\r\n        return \"image/jpeg\";\r\n      case \"png\":\r\n        return \"image/png\";\r\n      case \"gif\":\r\n        return \"image/gif\";\r\n      case \"bmp\":\r\n        return \"image/bmp\";\r\n      case \"webp\":\r\n        return \"image/webp\";\r\n      case \"svg\":\r\n        return \"image/svg+xml\";\r\n      case \"ico\":\r\n        return \"image/x-icon\";\r\n      case \"tiff\":\r\n        return \"image/tiff\";\r\n      case \"psd\":\r\n        return \"image/vnd.adobe.photoshop\";\r\n      case \"ai\":\r\n        return \"application/postscript\";\r\n      case \"eps\":\r\n        return \"application/postscript\";\r\n      case \"indd\":\r\n        return \"application/x-indesign\";\r\n      case \"raw\":\r\n        return \"image/x-raw\";\r\n      case \"cr2\":\r\n        return \"image/x-canon-cr2\";\r\n      case \"nef\":\r\n        return \"image/x-nikon-nef\";\r\n      case \"orf\":\r\n        return \"image/x-olympus-orf\";\r\n      case \"rw2\":\r\n        return \"image/x-panasonic-rw2\";\r\n      case \"pef\":\r\n        return \"image/x-pentax-pef\";\r\n      case \"arw\":\r\n        return \"image/x-sony-arw\";\r\n      case \"dng\":\r\n        return \"image/x-adobe-dng\";\r\n      case \"x3f\":\r\n        return \"image/x-sigma-x3f\";\r\n      case \"cr3\":\r\n        return \"image/x-canon-cr3\";\r\n      case \"heic\":\r\n        return \"image/heic\";\r\n      case \"heif\":\r\n        return \"image/heif\";\r\n      case \"avif\":\r\n        return \"image/avif\";\r\n  \r\n      // application\r\n      case \"pdf\":\r\n        return \"application/pdf\";\r\n      case \"txt\":\r\n        return \"text/plain\";\r\n  \r\n      // text\r\n      case \"html\":\r\n        return \"text/html\";\r\n      case \"css\":\r\n        return \"text/css\";\r\n      case \"js\":\r\n        return \"application/javascript\";\r\n      case \"json\":\r\n        return \"application/json\";\r\n      case \"xml\":\r\n        return \"application/xml\";\r\n  \r\n      // archive\r\n      case \"zip\":\r\n        return \"application/zip\";\r\n      case \"rar\":\r\n        return \"application/x-rar-compressed\";\r\n      case \"7z\":\r\n        return \"application/x-7z-compressed\";\r\n      default:\r\n        return \"application/octet-stream\";\r\n    }\r\n  }","import type { TerminalColor } from '../types/index.type';\r\n\r\n/**\r\n * Utility functions for terminal colors.\r\n * These functions provide ANSI escape codes for styling terminal output.\r\n * @module TerminalColors\r\n * This module exports an object containing ANSI escape codes for various text styles and colors.\r\n * You can use these codes to format terminal output in Node.js applications.\r\n * @example\r\n * import { TerminalColors as TC } from '@/shared/utils/colors';\r\n * console.log(`${TC.RED}This text is red${TC._reset}`);\r\n * @see {@link https://en.wikipedia.org/wiki/ANSI_escape_code} for more information\r\n */\r\nexport const TerminalColors: TerminalColor = {\r\n    _reset: '\\x1b[0m',\r\n    _bright: '\\x1b[1m',\r\n    _dim: '\\x1b[2m',\r\n    _italic: '\\x1b[3m',\r\n    _underline: '\\x1b[4m',\r\n    _blink: '\\x1b[5m',\r\n    _reverse: '\\x1b[7m',\r\n    _hidden: '\\x1b[8m',\r\n    _strikethrough: '\\x1b[9m',\r\n\r\n    // Foreground colors\r\n    BLACK: '\\x1b[30m',\r\n    RED: '\\x1b[31m',\r\n    GREEN: '\\x1b[32m',\r\n    YELLOW: '\\x1b[33m',\r\n    BLUE: '\\x1b[34m',\r\n    MAGENTA: '\\x1b[35m',\r\n    CYAN: '\\x1b[36m',\r\n    WHITE: '\\x1b[37m',\r\n\r\n    // Bright foreground colors\r\n    BRIGHT_BLACK: '\\x1b[90m',\r\n    BRIGHT_RED: '\\x1b[91m',\r\n    BRIGHT_GREEN: '\\x1b[92m',\r\n    BRIGHT_YELLOW: '\\x1b[93m',\r\n    BRIGHT_BLUE: '\\x1b[94m',\r\n    BRIGHT_MAGENTA: '\\x1b[95m',\r\n    BRIGHT_CYAN: '\\x1b[96m',\r\n    BRIGHT_WHITE: '\\x1b[97m',\r\n\r\n    // Background colors\r\n    BBLACK: '\\x1b[40m',\r\n    BRED: '\\x1b[41m',\r\n    BGREEN: '\\x1b[42m',\r\n    BYELLOW: '\\x1b[43m',\r\n    BBLUE: '\\x1b[44m',\r\n    BMAGENTA: '\\x1b[45m',\r\n    BCYAN: '\\x1b[46m',\r\n    BWHITE: '\\x1b[47m',\r\n\r\n    // Bright background colors\r\n    BBRIGHT_BLACK: '\\x1b[100m',\r\n    BBRIGHT_RED: '\\x1b[101m',\r\n    BBRIGHT_GREEN: '\\x1b[102m',\r\n    BBRIGHT_YELLOW: '\\x1b[103m',\r\n    BBRIGHT_BLUE: '\\x1b[104m',\r\n    BBRIGHT_MAGENTA: '\\x1b[105m',\r\n    BBRIGHT_CYAN: '\\x1b[106m',\r\n    BBRIGHT_WHITE: '\\x1b[107m',\r\n\r\n    // 256-color support functions\r\n    fg256: (n: number) => `\\x1b[38;5;${n}m`,\r\n    bg256: (n: number) => `\\x1b[48;5;${n}m`,\r\n\r\n    // RGB color support functions\r\n    fgRGB: (r: number, g: number, b: number) => `\\x1b[38;2;${r};${g};${b}m`,\r\n    bgRGB: (r: number, g: number, b: number) => `\\x1b[48;2;${r};${g};${b}m`,\r\n};","\r\n/**\r\n * Time utility class for handling date and time formatting.\r\n * This class provides methods to format dates in various ways, including human-readable formats,\r\n * ISO strings, and formats suitable for logging or saving to a database.\r\n */\r\nexport class Time {\r\n  private static formatDateToParts(\r\n    date: Date,\r\n    locale?: string | null,\r\n    timeZone?: string | null\r\n  ): { [key: string]: string } {\r\n    // Validate date input\r\n    if (!date || !(date instanceof Date) || isNaN(date.getTime())) {\r\n      throw new Error('Invalid date provided to formatDateToParts');\r\n    }\r\n\r\n    const systemLocale = locale || Time.getSystemLocale();\r\n    const systemTimeZone = timeZone || Time.getSystemTimezone();\r\n\r\n    try {\r\n      const formatter = new Intl.DateTimeFormat(systemLocale, {\r\n        timeZone: systemTimeZone,\r\n        year: \"numeric\",\r\n        month: \"2-digit\",\r\n        day: \"2-digit\",\r\n        hour: \"2-digit\",\r\n        minute: \"2-digit\",\r\n        second: \"2-digit\",\r\n        hour12: false,\r\n      });\r\n\r\n      const formattedParts = formatter.formatToParts(date);\r\n      const dateParts: { [key: string]: string } = {};\r\n\r\n      formattedParts.forEach(({ type, value }) => {\r\n        dateParts[type] = value;\r\n      });\r\n\r\n      // Validate that all required parts are present\r\n      const requiredParts = ['year', 'month', 'day', 'hour', 'minute', 'second'];\r\n      for (const part of requiredParts) {\r\n        if (!dateParts[part]) {\r\n          throw new Error(`Missing date part: ${part}`);\r\n        }\r\n      }\r\n\r\n      return dateParts;\r\n    } catch (error) {\r\n      throw new Error(`Failed to format date: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n    }\r\n  }\r\n\r\n  private static formatDateString(dateParts: { [key: string]: string }, timeZone?: string): string {\r\n    const tz = timeZone || Time.getSystemTimezone();\r\n    \r\n    if (tz === 'UTC') {\r\n      return `${dateParts.year}-${dateParts.month}-${dateParts.day}T${dateParts.hour}:${dateParts.minute}:${dateParts.second}Z`;\r\n    } else {\r\n      // For non-UTC timezones, we should include the timezone offset\r\n      // This is more accurate than no suffix\r\n      const date = new Date(`${dateParts.year}-${dateParts.month}-${dateParts.day}T${dateParts.hour}:${dateParts.minute}:${dateParts.second}`);\r\n      const offset = Time.getTimezoneOffset(tz, date);\r\n      return `${dateParts.year}-${dateParts.month}-${dateParts.day}T${dateParts.hour}:${dateParts.minute}:${dateParts.second}${offset}`;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the timezone offset string for a given timezone\r\n   */\r\n  private static getTimezoneOffset(timeZone: string, date: Date): string {\r\n    try {\r\n      // Get the offset in minutes\r\n      const utcDate = new Date(date.toLocaleString(\"en-US\", { timeZone: \"UTC\" }));\r\n      const localDate = new Date(date.toLocaleString(\"en-US\", { timeZone }));\r\n      const offsetMinutes = (localDate.getTime() - utcDate.getTime()) / (1000 * 60);\r\n      \r\n      const hours = Math.floor(Math.abs(offsetMinutes) / 60);\r\n      const minutes = Math.abs(offsetMinutes) % 60;\r\n      const sign = offsetMinutes >= 0 ? '+' : '-';\r\n      \r\n      return `${sign}${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;\r\n    } catch {\r\n      // Fallback if timezone calculation fails\r\n      return '+00:00';\r\n    }\r\n  }\r\n\r\n  private static formatDateToSaveString(dateParts: { [key: string]: string }): string {\r\n    return `${dateParts.year}-${dateParts.month}-${dateParts.day}T${dateParts.hour}-${dateParts.minute}-${dateParts.second}`;\r\n  }\r\n\r\n  private static logFormat(dateParts: { [key: string]: string }): string {\r\n    return `${dateParts.day}/${dateParts.month}/${dateParts.year}:${dateParts.hour}:${dateParts.minute}:${dateParts.second}`;\r\n  }\r\n\r\n  /**\r\n   * Validates if a timezone is supported\r\n   */\r\n  public static isValidTimeZone(timeZone: string): boolean {\r\n    try {\r\n      Intl.DateTimeFormat(undefined, { timeZone });\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validates if a locale is supported\r\n   */\r\n  public static isValidLocale(locale: string): boolean {\r\n    try {\r\n      new Intl.DateTimeFormat(locale);\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the system's default timezone\r\n   */\r\n  public static getSystemTimezone(): string {\r\n    return Intl.DateTimeFormat().resolvedOptions().timeZone;\r\n  }\r\n\r\n  /**\r\n   * Gets the system's default locale\r\n   */\r\n  public static getSystemLocale(): string {\r\n    return Intl.DateTimeFormat().resolvedOptions().locale;\r\n  }\r\n\r\n  /**\r\n   * Gets both system locale and timezone\r\n   */\r\n  public static getSystemLocaleAndTimezone(): { locale: string; timeZone: string } {\r\n    const resolved = Intl.DateTimeFormat().resolvedOptions();\r\n    return {\r\n      locale: resolved.locale,\r\n      timeZone: resolved.timeZone\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Formats a date to a human-readable string using locale-specific formatting.\r\n   * @param data Object containing date, locale, and timeZone\r\n   * @returns The formatted date string respecting locale conventions\r\n   */\r\n  public static formatDateToHumanReadable(data: {\r\n    date?: Date;\r\n    locale?: string | null;\r\n    timeZone?: string | null;\r\n  }): string {\r\n    const { date, locale, timeZone } = data;\r\n    const targetDate = date || new Date();\r\n    const systemLocale = locale || Time.getSystemLocale();\r\n    const systemTimeZone = timeZone || Time.getSystemTimezone();\r\n\r\n    try {\r\n      const formatter = new Intl.DateTimeFormat(systemLocale, {\r\n        timeZone: systemTimeZone,\r\n        year: \"numeric\",\r\n        month: \"2-digit\",\r\n        day: \"2-digit\",\r\n        hour: \"2-digit\",\r\n        minute: \"2-digit\",\r\n        second: \"2-digit\",\r\n        hour12: false,\r\n      });\r\n\r\n      return formatter.format(targetDate);\r\n    } catch (error) {\r\n      // Fallback to basic format if locale/timezone issues\r\n      const dateParts = Time.formatDateToParts(targetDate, locale, timeZone);\r\n      return `${dateParts.day}/${dateParts.month}/${dateParts.year} ${dateParts.hour}:${dateParts.minute}:${dateParts.second}`;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the current time formatted as a string suitable for saving.\r\n   * This format is `YYYY-MM-DDTHH-MM-SSZ`, which is useful for file naming or database storage.\r\n   */\r\n  public static getCurrentTimeToSaveString(\r\n    locale?: string | null,\r\n    timeZone?: string | null\r\n  ): string {\r\n    const now = new Date();\r\n    const dateParts = Time.formatDateToParts(now, locale, timeZone);\r\n    return Time.formatDateToSaveString(dateParts);\r\n  }\r\n\r\n  /**\r\n   * Returns the current time as a Date object in the specified timezone.\r\n   * Note: This returns a new Date object representing the current moment,\r\n   * but when displayed it will show the time in the specified timezone.\r\n   */\r\n  public static getCurrentTime(\r\n    locale?: string | null,\r\n    timeZone?: string | null\r\n  ): Date {\r\n    // Simply return current time - timezone conversion is for display purposes\r\n    return new Date();\r\n  }\r\n\r\n  /**\r\n   * Returns the current time formatted as a string.\r\n   * This format includes proper timezone information (Z for UTC, +HH:MM for others).\r\n   */\r\n  public static getCurrentTimeToString(\r\n    locale?: string | null,\r\n    timeZone?: string | null\r\n  ): string {\r\n    const now = new Date();\r\n    const dateParts = Time.formatDateToParts(now, locale, timeZone);\r\n    const tz = timeZone || Time.getSystemTimezone();\r\n    return Time.formatDateString(dateParts, tz);\r\n  }\r\n\r\n  /**\r\n   * Returns the current time in a human-readable format.\r\n   * This format is `DD/MM/YYYY HH:MM:SS`, which is suitable for display to users.\r\n   */\r\n  public static getCurrentTimeToHumanReadable(\r\n    locale?: string | null,\r\n    timeZone?: string | null\r\n  ): string {\r\n    const now = new Date();\r\n    return Time.formatDateToHumanReadable({ date: now, locale, timeZone });\r\n  }\r\n\r\n  /**\r\n   * Safely parses a date string or date object\r\n   */\r\n  public static parseDate(input: string | Date | number): Date {\r\n    if (input instanceof Date) {\r\n      if (isNaN(input.getTime())) {\r\n        throw new Error('Invalid Date object provided');\r\n      }\r\n      return input;\r\n    }\r\n    \r\n    if (typeof input === 'number') {\r\n      const date = new Date(input);\r\n      if (isNaN(date.getTime())) {\r\n        throw new Error('Invalid timestamp provided');\r\n      }\r\n      return date;\r\n    }\r\n    \r\n    if (typeof input === 'string') {\r\n      const date = new Date(input);\r\n      if (isNaN(date.getTime())) {\r\n        throw new Error(`Unable to parse date string: \"${input}\"`);\r\n      }\r\n      return date;\r\n    }\r\n    \r\n    throw new Error('Input must be a Date object, timestamp number, or valid date string');\r\n  }\r\n\r\n  /**\r\n   * Returns the current time formatted for logging.\r\n   * This format is `DD/MM/YYYY:HH:MM:SS`, which is useful for log entries.\r\n   */\r\n  public static getTimeToLogFormat(\r\n    locale?: string | null,\r\n    timeZone?: string | null\r\n  ): string {\r\n    const now = new Date();\r\n    const dateParts = Time.formatDateToParts(now, locale, timeZone);\r\n    return Time.logFormat(dateParts);\r\n  }\r\n\r\n}\r\n","import { TerminalColors as TC } from \"@/terminal/terminalColors\";\r\nimport { LogReturn } from \"@/types/index.type\";\r\nimport { Time } from \"@/utils/time\";\r\n\r\n\r\n/**\r\n * Logger class provides static methods for logging messages to the console with different severity levels.\r\n * \r\n * It supports the following log levels: \r\n * - DEBUG\r\n * - WARN\r\n * - ERROR\r\n * - INFO\r\n * - SUCCESS \r\n * \r\n * each with distinct colors for better visibility.\r\n * The logger also includes a custom log method that allows specifying a type and color.\r\n * Each log entry is timestamped and can optionally include the name of the function from which it was called.\r\n */\r\n\r\nexport class Logger {\r\n    /**\r\n     * Flag to control whether to show function names in regular Logger methods\r\n     * Set to false by default - use Logger.pfn for function names\r\n     */\r\n    public static showFunctionName: boolean = false;\r\n\r\n    /**\r\n     * Proxy object for logging with function names\r\n     */\r\n    public static pfn = {\r\n        success: (...args: any[]): LogReturn => this.logWithReturn(\"SUCCESS\", true, ...args),\r\n        error: (...args: any[]): LogReturn => this.logWithReturn(\"ERROR\", true, ...args),\r\n        warn: (...args: any[]): LogReturn => this.logWithReturn(\"WARN\", true, ...args),\r\n        info: (...args: any[]): LogReturn => this.logWithReturn(\"INFO\", true, ...args),\r\n        debug: (...args: any[]): LogReturn => this.logWithReturn(\"DEBUG\", true, ...args),\r\n        custom: (opt: { type: string, color?: keyof typeof TC }, ...args: any[]): LogReturn => \r\n            this.customWithReturn(opt, true, ...args)\r\n    };\r\n\r\n    private static getCallerName(): string {\r\n        if (!this.showFunctionName) {\r\n            return \"\";\r\n        }\r\n        \r\n        const err = new Error();\r\n        if (err.stack) {\r\n            const stackLines = err.stack.split(\"\\n\");\r\n            \r\n            for (let i = 2; i < stackLines.length; i++) {\r\n                const line = stackLines[i];\r\n                \r\n                if (line.includes(\"Logger.log\") || \r\n                    line.includes(\"Logger.success\") || \r\n                    line.includes(\"Logger.error\") || \r\n                    line.includes(\"Logger.warn\") || \r\n                    line.includes(\"Logger.info\") || \r\n                    line.includes(\"Logger.debug\") || \r\n                    line.includes(\"Logger.custom\") ||\r\n                    line.includes(\"Function.getCallerName\") ||\r\n                    line.includes(\"Function.logWithReturn\") ||\r\n                    line.includes(\"Function.customWithReturn\") ||\r\n                    line.includes(\"at Object.<anonymous>\") || \r\n                    line.includes(\"Module._compile\") ||\r\n                    line.includes(\"at Module.load\") ||\r\n                    line.includes(\"transformer\")) {\r\n                    continue;\r\n                }\r\n                \r\n                if (line.includes(\"at <anonymous>\") && !line.match(/at\\s+<anonymous>\\s+\\(/)) {\r\n                    continue;\r\n                }\r\n                \r\n                if (line.trim() !== \"\") {\r\n                    let match = line.match(/at\\s+(\\w+)\\s+\\(/);\r\n                    if (match && match[1] && match[1] !== \"Object\" && match[1] !== \"Function\") {\r\n                        return `fn: ${match[1]}`;\r\n                    }\r\n                    \r\n                    if (line.includes(\"at <anonymous>\")) {\r\n                        return `fn: <anonymous>`;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return \"\";\r\n    }\r\n\r\n    private static getCallerNameForced(): string {\r\n        const err = new Error();\r\n        if (err.stack) {\r\n            const stackLines = err.stack.split(\"\\n\");\r\n            \r\n            // DEBUG: Log the stack trace\r\n            // console.log(\"=== DEBUG STACK ===\");\r\n            // stackLines.forEach((line, i) => console.log(`${i}: ${line}`));\r\n            // console.log(\"===================\");\r\n            \r\n            // Look for the first line that is NOT from Logger class methods\r\n            for (let i = 2; i < stackLines.length; i++) {\r\n                const line = stackLines[i];\r\n                \r\n                if (line.includes(\"Logger.log\") || \r\n                    line.includes(\"Logger.success\") || \r\n                    line.includes(\"Logger.error\") || \r\n                    line.includes(\"Logger.warn\") || \r\n                    line.includes(\"Logger.info\") || \r\n                    line.includes(\"Logger.debug\") || \r\n                    line.includes(\"Logger.custom\") ||\r\n                    line.includes(\"Function.getCallerName\") ||\r\n                    line.includes(\"Function.logWithReturn\") ||\r\n                    line.includes(\"Function.customWithReturn\") ||\r\n                    line.includes(\"at Object.<anonymous>\") || \r\n                    line.includes(\"Module._compile\") ||\r\n                    line.includes(\"at Module.load\") ||\r\n                    line.includes(\"transformer\")) {\r\n                    continue;\r\n                }\r\n                \r\n                if (line.includes(\"at <anonymous>\") && !line.match(/at\\s+<anonymous>\\s+\\(/)) {\r\n                    continue;\r\n                }\r\n                \r\n                if (line.trim() !== \"\") {\r\n                    let match = line.match(/at\\s+(\\w+)\\s+\\(/);\r\n                    if (match && match[1] && match[1] !== \"Object\" && match[1] !== \"Function\") {\r\n                        return `fn: ${match[1]}`;\r\n                    }\r\n                    \r\n                    if (line.includes(\"at <anonymous>\")) {\r\n                        return `fn: <anonymous>`;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return \"\";\r\n    }\r\n\r\n    private static log(type: \"DEBUG\" | \"WARN\" | \"ERROR\" | \"INFO\" | \"SUCCESS\", ...args: any[]) {\r\n        const colorMap = {\r\n            DEBUG: TC.MAGENTA,\r\n            WARN: TC.BYELLOW,\r\n            ERROR: TC.RED,\r\n            INFO: TC.BLUE,\r\n            SUCCESS: TC.GREEN,\r\n        };\r\n        const color = colorMap[type] || TC._reset;\r\n        const currentTime = Time.getTimeToLogFormat();\r\n        const functionName = this.getCallerName();\r\n        const message = args.map(a => {\r\n            if (a instanceof Error) {\r\n                return a.stack || a.message;\r\n            }\r\n            if (typeof a === \"object\") {\r\n                return JSON.stringify(a);\r\n            }\r\n            return String(a);\r\n        }).join(\" \");\r\n        const logMethod = type === \"ERROR\" || type === \"WARN\" ? console.log : type === \"INFO\" ? console.info : console.log;\r\n        logMethod(`${TC._dim}[${currentTime}]${TC._reset} ${color}[${type}]${TC._reset} ${functionName}: ${message}`);\r\n    }\r\n\r\n    private static logWithReturn(type: \"DEBUG\" | \"WARN\" | \"ERROR\" | \"INFO\" | \"SUCCESS\", withFunctionName: boolean, ...args: any[]): LogReturn {\r\n        const colorMap = {\r\n            DEBUG: TC.MAGENTA,\r\n            WARN: TC.BYELLOW,\r\n            ERROR: TC.RED,\r\n            INFO: TC.BLUE,\r\n            SUCCESS: TC.GREEN,\r\n        };\r\n        const color = colorMap[type] || TC._reset;\r\n        const currentTime = Time.getTimeToLogFormat();\r\n        \r\n        const detectedFunctionName = this.getCallerNameForced();\r\n        \r\n        const displayFunctionName = withFunctionName ? detectedFunctionName : (this.showFunctionName ? this.getCallerName() : \"\");\r\n        \r\n        let processedMessage: any;\r\n        if (args.length === 1) {\r\n            processedMessage = args[0];\r\n        } else if (args.length > 1) {\r\n            processedMessage = args;\r\n        } else {\r\n            processedMessage = \"\";\r\n        }\r\n        \r\n        // For console output\r\n        const consoleMessage = args.map(a => {\r\n            if (a instanceof Error) {\r\n                return a.stack || a.message;\r\n            }\r\n            if (typeof a === \"object\") {\r\n                return JSON.stringify(a);\r\n            }\r\n            return String(a);\r\n        }).join(\" \");\r\n        \r\n        const logMethod = type === \"ERROR\" || type === \"WARN\" ? console.log : type === \"INFO\" ? console.info : console.log;\r\n        logMethod(`${TC._dim}[${currentTime}]${TC._reset} ${color}[${type}]${TC._reset} ${displayFunctionName}: ${consoleMessage}`);\r\n        \r\n        const result: LogReturn = {\r\n            pfn: detectedFunctionName.replace(\"fn: \", \"\"),\r\n            timestamp: currentTime,\r\n            message: processedMessage,\r\n            level: type\r\n        };\r\n        \r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Logs a success message.\r\n     * @param args - The messages to log.\r\n     * @returns LogReturn object with structured data\r\n     */\r\n    static success(...args: any[]): LogReturn {\r\n        return this.logWithReturn(\"SUCCESS\", this.showFunctionName, ...args);\r\n    }\r\n\r\n    /**\r\n     * Logs an error message.\r\n     * @param args - The messages to log.\r\n     * @returns LogReturn object with structured data\r\n     */\r\n    static error(...args: any[]): LogReturn {\r\n        return this.logWithReturn(\"ERROR\", this.showFunctionName, ...args);\r\n    }\r\n\r\n    /**\r\n     * Logs a warning message.\r\n     * @param args - The messages to log.\r\n     * @returns LogReturn object with structured data\r\n     */\r\n    static warn(...args: any[]): LogReturn {\r\n        return this.logWithReturn(\"WARN\", this.showFunctionName, ...args);\r\n    }\r\n\r\n    /**\r\n     * Logs an informational message.\r\n     * @param args - The messages to log.\r\n     * @returns LogReturn object with structured data\r\n     */\r\n    static info(...args: any[]): LogReturn {\r\n        return this.logWithReturn(\"INFO\", this.showFunctionName, ...args);\r\n    }\r\n\r\n    /**\r\n     * Logs a debug message.\r\n     * @param args - The messages to log.\r\n     * @returns LogReturn object with structured data\r\n     */\r\n    static debug(...args: any[]): LogReturn {\r\n        return this.logWithReturn(\"DEBUG\", this.showFunctionName, ...args);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Custom log method that allows specifying a type and color.\r\n     * @param opt - Options for the custom log.\r\n     * @param args - The messages to log.\r\n     * @returns LogReturn object with structured data\r\n     */\r\n    static custom(opt: { type: string, color?: keyof typeof TC }, ...args: any[]): LogReturn {\r\n        return this.customWithReturn(opt, this.showFunctionName, ...args);\r\n    }\r\n\r\n    private static customWithReturn(opt: { type: string, color?: keyof typeof TC }, withFunctionName: boolean, ...args: any[]): LogReturn {\r\n        const logColor = opt.color || \"CYAN\";\r\n        const currentTime = Time.getTimeToLogFormat();\r\n        \r\n        const detectedFunctionName = this.getCallerNameForced();\r\n        \r\n        const displayFunctionName = withFunctionName ? detectedFunctionName : (this.showFunctionName ? this.getCallerName() : \"\");\r\n        \r\n        let processedMessage: any;\r\n        if (args.length === 1) {\r\n            processedMessage = args[0];\r\n        } else if (args.length > 1) {\r\n            processedMessage = args;\r\n        } else {\r\n            processedMessage = \"\";\r\n        }\r\n        \r\n        const consoleMessage = args.map(a => {\r\n            if (a instanceof Error) {\r\n                return a.stack || a.message;\r\n            }\r\n            if (typeof a === \"object\") {\r\n                return JSON.stringify(a);\r\n            }\r\n            return String(a);\r\n        }).join(\" \");\r\n        \r\n        console.log(`${TC._dim}[${currentTime}]${TC._reset} ${TC[logColor]}[${opt.type}]${TC._reset} ${displayFunctionName}: ${consoleMessage}`);\r\n        \r\n        const result: LogReturn = {\r\n            pfn: detectedFunctionName.replace(\"fn: \", \"\"),\r\n            timestamp: currentTime,\r\n            message: processedMessage,\r\n            level: opt.type\r\n        };\r\n        \r\n        return result;\r\n    }\r\n}\r\n","import { createInterface, Interface } from \"readline\";\r\nimport dotenv from \"dotenv\"\r\ndotenv.config();\r\n\r\n/**\r\n * Terminal class provides methods for interacting with the terminal.\r\n * It includes functionalities for prompting user input, clearing the screen,\r\n * pausing execution, and parsing environment variables.\r\n */\r\nexport class Terminal {\r\n    private static instance: Terminal\r\n    private readlineInterface: Interface;\r\n\r\n    constructor() {\r\n        this.readlineInterface = createInterface({\r\n            input: process.stdin,\r\n            output: process.stdout,\r\n            terminal: true,\r\n            completer: (line: string) => {\r\n                const completions = [\"help\", \"exit\", \"clear\"];\r\n                const hits = completions.filter((c) => c.startsWith(line));\r\n                return [hits.length ? hits : completions, line];\r\n            },\r\n        });\r\n    }\r\n\r\n    public getInstance() {\r\n        if (!Terminal.instance) {\r\n            Terminal.instance = new Terminal();\r\n        }\r\n        return Terminal.instance;\r\n    }\r\n\r\n    /**\r\n     * Prompts the user for input and returns the response.\r\n     * @param question The question to ask the user.\r\n     * @returns A promise that resolves to the user's input.\r\n     */\r\n    public question(question?: string): Promise<string> {\r\n        return new Promise((resolve) => {\r\n            this.readlineInterface.question(question ? question + \": \" : \": \", (answer) => {\r\n                resolve(answer);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Closes the terminal interface and exits the process.\r\n     * This function is useful for gracefully shutting down the terminal.\r\n     * @param code The exit code (default is 0).\r\n     * @example\r\n     * terminal.close(0); // Closes the terminal and exits with code 0\r\n     * terminal.close(1); // Closes the terminal and exits with code 1\r\n     * terminal.close();  // Closes the terminal and exits with code 0\r\n     * @see {@link https://nodejs.org/api/process.html#process_process_exit_code} for more information\r\n     */\r\n    public close(code: number = 0) {\r\n        this.readlineInterface.close();\r\n        process.exit(code);\r\n    }\r\n\r\n    /**\r\n     * Prompts the user for input without a specific question.\r\n     * This function is useful for creating a prompt without a predefined question.\r\n     * It simply displays a prompt symbol (\": \") and waits for user input.\r\n     */\r\n    public prompt() {\r\n        this.readlineInterface.prompt();\r\n    }\r\n\r\n    /**\r\n     * Clears the terminal screen.\r\n     * @returns A promise that resolves to the user's input.\r\n     */\r\n    public clear() {\r\n        process.stdout.write(\"\\x1Bc\");\r\n    }\r\n\r\n    /**\r\n     * Pauses execution for a specified duration (in seconds), similar to Python's sleep.\r\n     * @param duration Duration in seconds\r\n     */\r\n    public sleep(duration: number): Promise<void> {\r\n        return new Promise((resolve) => setTimeout(resolve, duration * 1000));\r\n    }\r\n\r\n    /**\r\n     * Parses environment variables that start with a given prefix.\r\n     * @param prefix The prefix to filter environment variables.\r\n     * @returns An object containing arrays of keys and values.\r\n     */\r\n    public envParser(prefix: string): { keys: string[]; values: string[] } {\r\n        const envKeys = Object.keys(process.env).filter((key) =>\r\n            key.startsWith(prefix)\r\n        );\r\n        const keys: string[] = [];\r\n        const values: string[] = [];\r\n\r\n        envKeys.forEach((key) => {\r\n            if (process.env[key]) {\r\n                keys.push(key);\r\n                values.push(process.env[key]!);\r\n            }\r\n        });\r\n\r\n        return { keys, values };\r\n    }\r\n}\r\n\r\n/**\r\n * Singleton instance of the Terminal class.\r\n * You can use this instance to interact with the terminal throughout your application.\r\n */\r\nexport const terminal = new Terminal();\r\n"],"mappings":"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","names":["chokidar","dotenv","resolve"]}